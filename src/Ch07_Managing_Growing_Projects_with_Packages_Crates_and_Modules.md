# 使用包、代码箱与模组管理不断增长的项目

**Managing Growing Projects with Packages, Crates and Modules**


当咱们编写大型程序时，组织咱们的代码，将变得日益重要。通过对相关功能进行分组，并将具有不同功能的代码分开，咱们就会弄清楚，在哪里可以找到实现某项特定功能的代码，以及在哪里可以改变某项特性的工作方式。

到目前为止，我们编写的程序，都是在一个文件的一个模块中。随着项目的增长，咱们应通过把代码拆分为多个模块，然后拆分为多个文件来组织代码。一个包可以包含多个二进制代码箱，也可以包含一个库代码箱。随着包的增长，咱们可以将各个部分，提取到独立的代码箱中，成为外部依赖。本章将介绍所有这些技巧。对于由一组相互关联，共同发展的包组成的超大型项目，Cargo 提供了 *工作空间，workspaces*，我们将在第 14 章的 [Cargo 工作空间](../crates-io/workspace.md) 小节中介绍。

我们还将讨论对实现细节进行封装的问题，这可以让咱们在更高层次上重用代码：一旦咱们实现了某个操作，其他代码就可以通过其公共接口，调用你的代码，而不必知道该操作是如何实现的。咱们编写代码的方式，定义了哪些部分是公开供其他代码使用的，哪些部分是私有的，咱们保留更改权利的实现细节。这是减少咱们必须记住的细节数量（从而减轻编程者负担）的方法。

一个相关的概念是作用域：代码被写下之处的嵌套上下文，有着一组被定义为 “在作用域中” 的名字。在读取、编写和编译代码时，程序员和编译器都需要知道，某个特定点位上的特定名字，是否引用了某个变量、函数、结构体、枚举、模组、常量，或其他项目，以及该项目的含义。咱们可以创建出作用域，并改变哪些名字，在作用域内，哪些在作用域外。在同一个作用域中，不能有两个同名的项目；有些工具，可以解决名字冲突问题。

Rust 有数项特性，可以让咱们管理咱们代码的组织，包括哪些细节是公开的，哪些细节是私有的，以及咱们程序中各个作用域中的有哪些名字。这些特性有时统称为 *模组系统*，包括：


- **包，packages**：让咱们构建、测试和共享代码箱的 Cargo 特性；

- **代码箱，crates**：产生库或可执行程序的模组树；

- **模组，modules** 与 **`use` 关键字**：让咱们控制路径的组织、作用域和隐私；

- **路径，paths**：命名项目（例如结构体、函数或模块）的一种方式。


在本章中，我们将介绍所有这些功能，讨论他们如何交互，并探讨如何使用他们来管理作用域。到本章结束时，咱们应对模组系统有扎实的了解，并能像专业人士一样，使用作用域！
