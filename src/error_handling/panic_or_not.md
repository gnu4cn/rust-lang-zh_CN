# 要 `panic!` 还是不要 `panic!`

**To `panic!` or Not to `panic!`**

那么，当代码死机无法恢复时，咱们要如何决定何时应该调用 `panic!`，何时应返回 `Result` 呢？对于任何错误情形，无论是否有可能恢复，咱们都可以调用 `panic!`，但这样一来，咱们就代表调用代码，做出了无法恢复的决定。在咱们选择返回一个 `Result` 值时，咱们就给了调用代码一些选择。调用代码可以选择以适合其情况的方式尝试恢复，或者他可以决定在这种情况下的某个 `Err` 值是不可恢复的，因此他可以调用 `panic!` 并将咱们的可恢复错误，变成一个不可恢复的错误。因此，在咱们定义某个可能失败的函数时，返回 `Result` 是一个不错的默认选择。

在示例程序、原型代码及测试等情况下，编写会死机而非返回一个 `Result` 的代码更为合适。我们来探讨一下原因，然后讨论在哪些情况下，编译器无法区分出失败是不可行的，但作为人类咱们却可以。本章最后将介绍一些，关于如何决定是否要在库代码中使用执行死机的一般指导原则。Let's explore why, then discuss situations in which the compiler can't tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.


## 示例程序、原型代码与测试

**Examples, Prototype Code, and Tests**

在咱们编写说明某些概念的示例程序时，同时包含一些健壮的错误处理代码，会使示例程序变得不那么明了。在示例程序中，到像 `unwrap` 这样可能会死机的某个方法的调用，往往是作为咱们打算咱们应用程序处理错误方式的占位符，而根据咱们代码其余部分的操作，咱们程序处理错误方式可能不一样。

同样，在咱们原型设计时，准备好决定如何处理错误前，`unwrap` 和 `expect` 两个方法非常方便。他们会在咱们的代码中，留下一些清晰的标记，以便咱们准备好让程序更健壮时使用。

如果一次测试中的某个方法调用失败，咱们会希望整个测试都失败，即使该方法并不属于被测试的功能。因为 `panic!` 是标记测试失败的方式，调用 `unwrap` 或 `expect` 正是不二之选。



## 相比于编译器，咱们掌握了更多信息的情况

**Cases in Which You Have More Information Than the Compiler**

当咱们有其他确保 `Result` 值将有着一个 `OK` 值的逻辑时，调用 `unwrap` 或 `expect` 也是合适的，但编译器并不理解这些逻辑。咱们仍将有个咱们需要处理的 `Result` 值：无论咱们调用的是何种操作，在一般情况下都有可能失败，即使在咱们特定情况下该操作逻辑上是不可行的。若咱们能通过手动检查代码，确保咱们绝不会有个 `Err` 变种，那么调用 `unwrap` 就是完全可接受的，甚至最好在 `expect `文本中，记录下咱们认为不会出现 `Err` 变种的原因。下面是个例子：


```rust
fn main () {
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("硬编码的 IP 地址应是有效的");
}
```


通过解析一个硬编码字符串，我们创建出一个 `IpAddr` 实例。我们可以看到，`127.0.0.1` 是个有效的 IP 地址，因此在这里使用 `expect` 是可接受的。然而，有着一个硬编码的有效字符串，并不会改变 `parse` 这个方法的返回类型：我们仍会得到一个 `Result` 值，同时编译器仍将让我们按照 `Err` 变种为一种可能性一样，处理这个 `Result`，因为编译器还不够聪明，无法发现这个字符串始终是个有效的 IP 地址。在这个 IP 地址字符串是来自用户，而不是硬编码到程序中的时，就因此 *确实* 存在失败的可能性，那么我们肯定就会希望以一种更健壮的方式，处理这个 `Result`。在将来我们需要从其他来源获取该 IP 地址时，那么提及这个 IP 地址是硬编码的假设，将提醒我们将 `expect` 修改成更好的错误处理代码。


## 错误处理指南

**Guidelines for Error Handling**

当咱们的代码有可能陷入某种糟糕的状态时，那么最好让咱们的代码死机。在此语境下，所谓 *糟糕状态，bad state* 是指某个假定、保证、合约，或恒定值被破坏，例如在无效值、矛盾值或缺失值被传递给咱们的代码时 -- 再加上以下一种或多种情况：

- 糟糕状态是指意想不到的某种情况，与偶尔会发生的情况相反，比如错误格式的用户输入数据等；

- 咱们此处之后的代码，需要依赖于不再处于这种不良状态，而不是在每一步都检查问题；

- 并无以咱们所使用类型，编码这些信息的某种良好方式。我们将在第 18 章 [“将状态和行为编码为类型”](../oop/implementing.md#将状态与行为编码为类型) 中，举例说明这个意思。

如果有人调用了咱们的代码并传入不合理的值，那么最好是咱们尽可能返回某个错误，这样该库的用户就可以决定，他们在这种情况下要做什么。但是，如果继续下去可能不安全或有害，那么最好的选择就可能是调用 `panic!`，并提醒使用咱们库的人他们代码中的错误，以便他们在开发过程中修复错误。类似地，若咱们调用的外部代码不在咱们的掌控中，而他返回了咱们无法修复的某种无效状态，这时通常也适合调用 `panic!`。

不过，当失败属于预期中的时，返回一个 `Result` 就比调用一次 `panic!` 更合适。例如，某个解析器得到畸形数据，或者某次 HTTP 请求返回了一个表明咱们已达速率限制的状态时。在这些情况下，返回一个 `Result` 就表明失败是预期的、调用代码必须决定如何处理的一种可能。

当咱们的代码执行某项在其调用代码用到无效值，则可能会给用户带来风险的操作时，咱们的代码就应首先检查这些值是有效的，并在这些值不是有效的时死机。这主要是出于安全原因：尝试在无效数据上操作，会咱们使代码暴露于漏洞之中。这是标准库会在咱们尝试越界内存访问时，将调用 `panic!` 的主要原因：尝试访问不属于当前数据结构的内存，是一项常见的安全问题。函数通常都有着 *合约，contracts*：只有在输入满足特定要求时，函数的行为才有保证。在违反合约时死机是有道理的，因为违反合约总是表明某种调用方错误，a caller-side bug，而这并不是咱们希望调用代码必须显式处理的错误类型。事实上，并没有调用代码要恢复的合理方法；调用的 *程序员* 需要修复代码。函数的合约，尤其是当违反合约时将导致死机，应在函数的 API 文档中加以说明。


但是，在全部的函数中，进行大量错误检查，则会显得冗长而烦人。幸运的是，可使用 Rust 的类型系统（并因此由编译器完成类型检查），来完成许多的检查。在函数有着作为参数的特定类型时，就可以在知悉编译器已经确保有着有效值的情况下，着手处理代码的业务逻辑。比如，在有着一个不同于 `Option` 的类型时，程序就期望有 *某个东西（something）* 而非 *什么也没有（nothing）*。代码这时就不必处理 `Some` 与 `None` 变种的两种情形：无疑将只有一种有着某个值的情形。尝试将无值传递给该函数的代码，甚至都不会编译，那么该函数就不必在运行时对那样的情况进行检查了。另一个示例则是使用某个诸如 `u32` 无符号整数，这就确保了参数绝不会是个负数。


## 创建用于验证的定制类型

**Creating Custom Types for Validation**


接下来将这个运用 Rust 的类型系统，来确保有着有效值的概念，进行进一步拓展，而看看创建一个用于验证的定制类型。回顾在第二章中的猜数游戏，其中的代码要求用户猜出一个 `1` 与 `100` 之间的数字。在将用户猜的数字与那里的秘密数字比对之前，是绝无对用户猜数是否处于 `1` 与 `100` 之间，进行过验证的；那里只验证过猜数为正数。在这个示例中，后果并不是非常可怕：这里的输出 “太大了” 或 “太小了” 仍将正确。但引导用户朝向有效的猜数，并在用户猜出不在该范围的数，与用户敲入了比如一些字母时，而有不同的表现，将是一项有用的功能增强。

完成此功能增强的一种方式，将是将猜数解析为一个 `i32` 而非仅仅为一个 `u32`，从而允许潜在的负数，并在随后键入一个该数位于范围中的检查，像下面这样：

```rust
        loop {
            // --跳过--

            let guess: i32 = match guess.trim().parse() {
               Ok(num) => num,
               Err(_) => { println! ("请输入一个数字！"); continue },
            };

            if guess < 1 || guess > 100 {
                println! ("秘密数字将在 1 和 100 之间");
                continue;
            }

            match guess.cmp(&secret_number) {
                // --跳过--
        }
```

其中的 `if` 表达式，对这里的值是否超出范围进行了检查，告诉用户这个问题，并调用 `continue` 来开始下一次循环迭代而请求另一个猜数。在这个 `if` 表达式之后，就可继续进行 `guess` 与秘密数字之间的比较，获悉 `guess` 是在 `1` 与 `100` 之间。

然而这并非一种理想的方案：若程序只运行在 `1` 与 `100` 之间的值这一点至关重要，且程序有着许多有此要求的函数，而在每个函数中都进行这样的一个检查，就会显得冗长乏味（并可能影响性能）。

相反，这里可以构造一种新类型，并将那些验证放入某个函数，从而创建出该类型的一个示例，而非在各个地方重复这些验证。那样的话，这些函数就可以在他们的签名中，安全地使用这种新类型，并信心十足地使用他们接收到的那些值了。下面清单 9-13 给出了一种定义 `Guess` 类型的方式，在 `new` 函数接收到一个 `1` 与 `100` 之间的值时，这种方式下将只创建一个 `Guess` 的实例。

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic! ("Guess 类型值必须在 1 与 100 之间，收到的是 {}", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

*清单 9-13：只会在值处于 `1` 与 `100` 之间，才继续执行的一个 `Guess` 类型*


首先，这里定义了一个名为 `Guess`，带有一个叫做 `value`、保存了一个 `i32` 值字段的结构体。这就是要存储数字的地方。

随后这里在 `Guess` 上实现了一个名为 `new` 的关联函数，其创建出一个 `Guess` 类型的实例。这个 `new` 函数被定义为有着一个名为 `value`、类型为 `i32` 的参数，以及要返回一个 `Guess` 类型值。`new` 函数体中的代码，对 `value` 进行了测试，从而确保 `value` 是在 `1` 与 `100` 之间。若 `value` 未通过此测试，那么就做出一个 `panic!` 调用，由于创建一个超出此范围的 `Guess` 会破坏 `Guess::new` 所依赖的合约，因此这就会警醒到编写调用代码的程序员，他们有个需要修复的代码错误。`Guess::new` 可能中止运行的条件，应在其公开的 API 文档中，进行说明。在第 14 章就会涉及到在所创建的文档中，表示 `panic!` 可能性的一些约定。在 `value` 通过该测试时，这里就会创建一个将 `value` 字段设置为那个 `value` 参数的新 `Guess` 类型值，并返回这个 `Guess` 类型值。

接下来，这里实现了一个名为 `value`、借用了 `self`，不带任何其他参数，并返回一个 `i32` 的方法。由于这类方法的目的，是要从一些字段获取数据并加以返回，因此有时就被叫做 *取值方法（getter）*。因为 `Guess` 结构体的这个 `value` 字段是私有的，那么这个公开方法就是必要的。这个 `value` 字段作为私有至关重要，这样使用这个 `Guess` 结构体的代码就不被允许直接设置 `value`：该模组外部的代码，*必须* 使用 `Guess::new` 函数，来创建 `Guess` 的实例，这样就确保了 `Guess` 不会有未经 `Guess::new` 函数中条件检查的 `value`。

现在某个有着一个 `1` 与 `100` 之间参数，或只返回 `1` 与 `100` 之间数字的函数，就可以在其函数签名中，声明他所取参数或其返回值为 `Guess` 类型而非 `i32` 类型，而不再需要在其函数体中完成任何额外检查了。


# 本章小结

Rust 的那些错误处理特性，被设计用于帮助编写更为健壮的代码。`panic!` 这个宏，发出了程序处于其无法处理状态的信号，并让咱们告知进程停下来，而不是尝试以无效或不正确的一些值继续运行。而 `Result` 这个枚举则使用了 Rust 的类型系统，来表示以代码可以从中恢复过来的某种方式的一些操作失败（the `Result` enum uses Rust's type system to indicate that operations might fail in a way that your code could recover from）。还可使用 `Result` 来告诉调用了咱们代码的代码，需要处理潜在的成功与失败情形。在一些适当情形下，运用 `panic!` 与 `Result` 就会令到咱们的代码在各种不可避免的问题面前，更加可靠。

既然这里已经见识到标准库在 `Option` 与 `Result` 枚举上，运用到泛型的一些有用方式，那么接下来就要谈及泛型的原理，以及怎样在咱们的代码中运用泛型。


（End）


