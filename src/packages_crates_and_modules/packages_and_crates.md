# 包与代码箱

**Packages and Crates**


我们要介绍的模块系统的头两个部分，是包与代码箱。

*代码箱，crate* 是 Rust 编译器一次要考虑的最小代码量。即使咱们运行的是 `rustc` 而不是 `cargo`，并只传递了一个源代码文件（就像我们在第 1 章 “编写和运行 Rust 程序” 小节中所做的那样），编译器也会将该文件，视为一个代码箱。代码箱可以包含模组，模组也可以定义在与该代码箱一起编译的其他文件中，正如我们将在接下来的小节中看到的那样。

代码箱有两种形式：二进制代码箱或库代码箱。*二进制板条箱，binary creates* 属于可以编译成咱们可以运行的可执行文件的程序，例如命令行程序或服务器。每个二进制代码箱，都必须有个名为 `main` 的函数，定义出可执行文件运行时会发生什么。到目前为止，我们创建的所有代码箱，都是二进制代码箱。

*库代码箱，library crates* 没有 `main` 函数，也不会编译成可执行文件。相反，他们定义了旨在与多个项目共享的功能。例如，我们在 [第 2 章](../Ch02_Programming_a_Guessing_Game.md#生成随机数) 中，使用的 `rand` 代码箱，就提供了生成随机数的功能。大多数时候，当 Rustaceans 说 “代码箱，crate” 时，他们指的是库代码箱，而且他们会将 “代码箱”，与一般的编程概念 “库，library” 互换使用。

而 *代码箱根，crate root*，则是个 Rust 编译器开始之处的源代码文件，并构成了咱们代码箱的 *根模组，root module*（我们将在 [定义控制作用域和隐私的模组](/packages_crates_and_modules/defining_modules.md) 小节，深入探讨模组）。

*包，package* 是提供了一组功能的一或多个代码箱的捆绑。包会包含一个描述如何构建这些代码箱的 `Cargo.toml` 文件。Cargo 实际上就是个包含了咱们用来构建代码的命令行工具的包。Cargo 包还包含该二进制代码箱所依赖的库代码箱。其他项目可以依赖于 Cargo 的库代码箱，使用与 Cargo 这个命令行工具所使用的同样逻辑。

某个包可以包含任意数量的二进制代码箱，但最多只能包含一个库代码箱。某个包必须至少包含一个代码箱，无论是库代码箱，还是二进制代码箱。

我们来看看当我们创建出某个软件包时，会发生什么。首先，我们输入命令 `cargo new`：


```console

$ cargo new my-project --vcs=none
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml  src
$ ls my-project/src
main.rs
```

在运行了 `cargo new` 之后，这里便使用 `ls` 来查看 Cargo 创建了些什么。在该项目目录下，有着一个 `Cargo.toml` 文件，这就给到咱们一个代码包。其中还有一个包含了 `main.rs` 的 `src` 目录。在文本编辑器中打开 `Cargo.toml` 文件，就会注意到其中并未提及 `src/main.rs`。Cargo 遵循了 `src/main.rs` 即为与该代码包同名二进制代码箱箱根，这样一条约定。与此类似，Cargo 还知道，在代码包目录包含了 `src/lib.rs` 时，那么这个代码包就包含了与该包同名的一个库代码箱，而那个 `src/lib.rs` 就是该库代码箱的箱根。Cargo 会将代码箱根文件，传递给 `rustc`，来构建出相应的库或二进制程序。

这里有一个只包含了 `src/main.rs` 的代码包，意味着他只包含了名为 `my-project` 的一个二进制代码箱。而在代码包同时包含了 `src/main.rs` 与 `src/lib.rs` 时，他就会有两个代码箱：一个二进制和一个库代码箱，二者都有着与该代码包同样的名字。通过将一些文件放入到 `src/bin` 目录，Rust 包就可以有多个二进制代码箱：其中的每个文件，都将是单独的二进制代码箱。



